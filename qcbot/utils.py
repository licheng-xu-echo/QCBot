from rdkit import Chem
from rdkit.Chem import AllChem
from molop import AutoParser
from molop.config import molopconfig
import numpy as np
import signal
from contextlib import contextmanager
pt = Chem.GetPeriodicTable()
molopconfig.quiet()
def generate_g16_input_file(gjf_file,atoms,coords,charge,multiplicity,method,jobtype,cpu,memory):
    information = [
    f'%nproc={cpu}',
    f'%mem={memory}GB',
    f'# {jobtype} {method}',
    "",
    "Generated by QuantumCalcAgent",
    "",
    f"{charge} {multiplicity}",
    ]
    for atom, coord in zip(atoms, coords):
        information.append(f"{atom:5s} {coord[0]:15f} {coord[1]:15f} {coord[2]:15f}")
        
    information += ["",""]
    with open(gjf_file, 'w') as f:
        f.write("\n".join(information))

def molop_parser(xyz_file):
    parser_mol = AutoParser(xyz_file)[0][-1]
    rdmol = parser_mol.rdmol
    charge = parser_mol.charge
    multiplicity = parser_mol.multiplicity
    coords = np.array(parser_mol.coords)
    atoms = [pt.GetElementSymbol(atom) for atom in parser_mol.atoms]
    return atoms,coords,charge,multiplicity

def smiles_to_xyz(smiles, output_file='molecule.xyz', add_hydrogens=True, optimize=True):
    """
    将SMILES字符串转换为三维分子结构并保存为XYZ文件
    
    参数：
    - smiles: SMILES字符串
    - output_file: 输出XYZ文件名（默认'molecule.xyz'）
    - add_hydrogens: 是否添加氢原子（默认True）
    - optimize: 是否进行力场优化（默认True）
    
    返回：
    - 成功返回True，失败返回False
    """
    try:
        # 1. 从SMILES生成分子对象
        mol = Chem.MolFromSmiles(smiles)
        mol.SetProp("_Name", smiles)
        if mol is None:
            raise ValueError("无效的SMILES字符串")
        
        # 2. 添加氢原子（可选）
        if add_hydrogens:
            mol = Chem.AddHs(mol)
            
        # 3. 生成3D坐标
        AllChem.EmbedMolecule(mol, AllChem.ETKDGv3())
        
        # 4. 力场优化（可选）
        if optimize:
            try:
                AllChem.MMFFOptimizeMolecule(mol)
            except:
                AllChem.UFFOptimizeMolecule(mol)
        
        # 5. 写入XYZ文件
        with open(output_file, 'w') as f:
            # 写入原子数头
            f.write(f"{mol.GetNumAtoms()}\n")
            f.write(f"{smiles}\n")
            
            # 写入原子坐标
            conf = mol.GetConformer()
            for atom in mol.GetAtoms():
                pos = conf.GetAtomPosition(atom.GetIdx())
                symbol = atom.GetSymbol()
                f.write(f"{symbol:4s} {pos.x:15f} {pos.y:15f} {pos.z:15f}\n")
        
        #print(f"成功生成3D结构并保存到：{os.path.abspath(output_file)}")
        return True
    
    except Exception as e:
        print(f"错误发生：{str(e)}")
        return False
    
class TimeoutException(Exception):
    pass

@contextmanager
def time_limit(seconds):
    """超时上下文管理器"""
    def signal_handler(signum, frame):
        raise TimeoutException("操作超时")
    signal.signal(signal.SIGALRM, signal_handler)
    signal.alarm(seconds)
    try:
        yield
    finally:
        signal.alarm(0)

def split_mol2_into_molecules(mol2_file):
    mol = Chem.MolFromMol2File(mol2_file, sanitize=False, removeHs=False)
    symbols = [atom.GetSymbol() for atom in mol.GetAtoms()]
    if not "H" in symbols:
        smi = Chem.MolToSmiles(mol)
        mol = Chem.MolFromSmiles("".join(smi.split("~")))
        mol = Chem.AddHs(mol)
        AllChem.EmbedMolecule(mol)
        print("There is no H atom in the mol2 file, so we add H atoms and generate 3D coordinates")
    if mol is None:
        return None
    # 存储所有分子的信息
    molecules = []

    # 拆分分子（如果存在不通过共价键相连的部分）
    mol_fragments = Chem.GetMolFrags(mol, asMols=True, sanitizeFrags=False)

    for fragment in mol_fragments:
        # 获取原子信息
        atoms = fragment.GetAtoms()
        elements = [atom.GetSymbol() for atom in atoms]  # 元素类型
        coords = fragment.GetConformer().GetPositions()  # 原子坐标
        
        # 存储分子信息
        molecules.append({
            "rdmol": fragment,
            "elements": elements,
            "coordinates": coords.tolist()  # 转换为列表
        })
    return molecules

def symbol_pos_to_xyz_file(symbols,positions,xyz_file,title=""):
    with open(xyz_file, 'w') as f:
        f.write(f"{len(symbols)}\n")
        f.write(f"{title}\n")
        for symbol, pos in zip(symbols, positions):
            f.write(f"{symbol:4s} {pos[0]:15f} {pos[1]:15f} {pos[2]:15f}\n")
            
def get_charge_and_mult(atoms, charge=0, is_atom=False):
    """
    计算分子体系的电荷和自旋多重度
    参数：
        mol_input: 分子SMILES表达式 或 原子符号列表(如 ['C','H','H','H','H'])
        charge: 预设电荷（默认0）
        is_atom: 是否为单原子体系（需特殊处理）
    返回：
        (charge, multiplicity)
    """


    # 计算总电子数（原子序数之和 - 电荷）
    if isinstance(atoms[0],int):
        total_e = sum(atoms) - charge
    else:
        total_e = sum(pt.GetAtomicNumber(symbol) for symbol in atoms) - charge
    multiplicity = 1  # 默认闭壳层

    # 自旋多重度判断逻辑
    if total_e % 2 == 1:  # 奇数电子
        multiplicity = 2
    elif is_atom:  # 单原子特殊处理[1,4](@ref)
        atomic_num = pt.GetAtomicNumber(atoms[0])
        valence_e = get_valence_electrons(atomic_num)
        multiplicity = 2 * (valence_e % 2) + 1 if valence_e < 14 else 3
    elif total_e == 0:  # 特殊情况处理
        raise ValueError("电子总数不能为0")

    return (charge, multiplicity)

def get_valence_electrons(atomic_num):
    """获取原子的价电子数（简化版）"""
    period = pt.GetPeriod(atomic_num)
    group = pt.GetGroup(atomic_num)
    
    if period == 1: return 1
    if period == 2: return min(group, 8)
    if period >=3:  # 过渡金属简化处理[4](@ref)
        return pt.GetNOuterElecs(atomic_num)
    return 0

def get_calc_time(log_file):
    with open(log_file,"r") as fr:
        lines = fr.readlines()
    elapsed_time = None
    job_cpu_time = None
    for line in lines[::-1][:10]:
        if "Elapsed time:" in line:
            d,_,h,_,m,_,s = line.strip().split()[2:9]
            d,h,m,s = float(d),float(h),float(m),float(s)
            elapsed_time = d*24*3600 + h*3600 + m*60 + s
        elif "Job cpu time:" in line:
            d,_,h,_,m,_,s = line.strip().split()[3:10]
            d,h,m,s = float(d),float(h),float(m),float(s)
            job_cpu_time = d*24*3600 + h*3600 + m*60 + s
    return elapsed_time,job_cpu_time